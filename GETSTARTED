From Richard Huber:

* Install Microblaze GNU Tools on Debian *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This page describes, how to install the GNU cross compiler tools for microblaze
on a debian system. There is a big endian and a little endian version in two
different git repositories. The ReconOS project requires the bit endian version.

First, clone into the git repository hosted by xilinx (big endian):

  git clone git://git.xilinx.com/xldk/microblaze_v2.0.git

Unpack the archive with:

  tar -xzf microblaze-unknown-linux-gnu.tgz

Add the path to the executables to your PATH environment variable:

  export PATH=$PATH:/<path to git repo>/microblaze_v2.0/microblaze-unknown-linux-gnu/bin

You may want to add this last command to your .bashrc so you don't have to
retype it any time you want to use the cross compiler.

* Install Xilinx 13.3er Tools on Debian *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Copy the DVD to a temporary directory on the harddrive. Change ownership
of /opt:

  chown -hR <username> /opt

Change the file mode of the install scripts to be executable:

  chmod a+x <tmp dir>/xsetup <tmp dir>/bin/lin64/*

Execute the install script and follow the instructions on the screen.
(Do not aquire any license keys in the wizard.)

  <tmp dir>/xsetup

Add the following lines to the .bashrc:

  export XILINXD_LICENSE_FILE=<blubber>
  source /opt/Xilinx/13.3/settings64.sh

Create the following link:

  ln /usr/bin/make /usr/bin/gmake

Establish a vpn connection to the ETHZ domain, start a new console and enter.

  ise

... to start the ISE project manager.

* Install Modelsim SE on Debian *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Install Sun Java6: Before you can start with the installation of modelsim, you
have to install sun's java. The installer does not work with open java.

Download the software: Download the software from the modelsim website into a
temporary directory.

License file: Set the environment variables for the modelsim license file:

  export LM_LICENSE_FILE=<blubber>
  export MGLS_LICENSE_FILE=<blubber>

Since you have to set these environment variables every time you want to work
with modelsim, we recommend to include these two lines in your .bashrc file.

Installation: Change permission of install.linux, execute it and follow the
instructions on the screen.

  chmod a+x install.linux
  ./install.linux

The recommended installation directory is /opt/modelsim/.

Run modelsim: You can start modelsim with the command

  /PATH/TO/MODELSIM/modeltech/bin/vsim

Alternatively, you may add:

  export PATH=$PATH:/PATH/TO/MODELSIM/modeltech/bin

... to your .bashrc file. If you did this, you can run modelsim with the
command:

  vsim

* Xilinx USB driver for linux *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Install required packages:

  sudo apt-get install fxload
  sudo apt-get install libusb-dev
  sudo apt-get install libftdi-dev

Navigate to the directory where you want to install the driver. Get the
driver source:

  git clone git://git.zerfleddert.de/usb-driver

Build the driver:

  cd usb-driver
  make

Run the setup setup script

  ./setup_pcusb

Restart the PC and plugin the JTAG cable. Verify that the SysACE switch is
configured correctly (see images docs/switch.jpg, docs/jumper.jpg).

* Setup ReconOS V3 *
~~~~~~~~~~~~~~~~~~~~

Clone the reconos v3 repository. Add the following lines to the .bashrc:

  export RECONOS=<path to reconos>/reconos_v3
  export PATH=$PATH:$RECONOS/tools
  export RECONOS_BOARD=ml605

Install the microblaze GNU tools as described above. Build the ReconOS libraries:

  cd $RECONOS/linux/fsl_driver
  make
  cd $RECONOS/linux/getpgd
  make
  cd $RECONOS/linux/libreconos
  make
  cd $RECONOS/linux/readpvr
  make

* Run the sort_demo Application *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Be sure that you set up ReconOS V3 correctly. Compile the software:

  cd $RECONOS/demos/sort_demo/linux
  make all

Setup the hardware design:

  $RECONOS/demos/sort_demo/hw/setup.sh

Synthesize hardware desing:

  cd $RECONOS/demos/sort_demo/hw/edk
  make clean all

Download the linux kernel via 

  git clone git://git.xilinx.com/linux-2.6-xlnx.git   or
  http://pc-techinf-25.cs.upb.de/ml605-linux/linux-2.6-xlnx.tar.bz2

... and extract it. Copy the device tree file from the ReconOS reference design
into the linux source.

cp reconos_v3/designs/ml605_linux_13.3/device_tree.dts linux-2.6-xlnx/arch/microblaze/boot/dts/

Compile the linux kernel:

  cd linux-2.6-xlnx make CROSS_COMPILE=microblaze-unknown-linux-gnu- ARCH=microblaze -j8 simpleImage.device_tree

Set up the NFS Server with the Root Filesystem. Install the xilinx usb calbe
driver as described.

Download the bitstream and the linux kernel to the FPGA:

  dow reconos_v3/demos/sort_demo/hw/edk/implementation/system.bit
  dow linux-2.6-xlnx/arch/microblaze/boot/simpleImage.device_tree

* NFS Server with Root Filesystem *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Create the exported directory (must be exactly this directory):

  mkdir /exports

Download the ReconOS root filesystem from

  http://pc-techinf-25.cs.upb.de/ml605-linux/rootfs_mb.tar

... into the created folder and untar it:

  tar -xvf /exports/rootfs_mb.tar

Set up a static ip for the NIC (assuming eth0 is connected to the board): Add
the following lines to /etc/network/interfaces

  auto eth0
  iface eth0 inet static
    address 192.168.30.1
    network 192.168.30.0
    netmask 255.255.255.0
    broadcast 192.168.30.255

Install the NFS server packet:

  apt-get install nfs-kernel-server

Configure the NFS server by adding the following line to /etc/exports:

  /exports/rootfs_mb  192.168.30.2(rw,async,no_root_squash)

Verify that you set up reconos correctly!

Copy the ReconOS libraries and scripts to the root folder of the NFS filesystem:

  cp $RECONOS/linux/fsl_driver/fsl.ko /exports/rootfs_mb/
  cp $RECONOS/linux/getpgd/getpgd.ko /exports/rootfs_mb/
  cp $RECONOS/linux/readpvr/readpvr /exports/rootfs_mb/
  cp $RECONOS/linux/scripts/load_fsl.sh /exports/rootfs_mb/
  cp $RECONOS/linux/scripts/load_getpgd.sh /exports/rootfs_mb/
  cp $RECONOS/linux/scripts/rcS /exports/rootfs_mb/

To activate the changes restart the NFS kernel-server service.

* Debug 'Hello World' from console *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Start Xilinx Microprocessor Debugger (XMD) Engine:

  rihuber@pc-10105:~$ xmd
  Xilinx Microprocessor Debugger (XMD) Engine
  Xilinx EDK 12.3 Build EDK_MS3.70d
  Copyright (c) 1995-2009 Xilinx, Inc.  All rights reserved.
  
  XMD%
  Connect the xmd to the hardware:
  
  XMD% connect mb mdm
  
  JTAG chain configuration
  --------------------------------------------------
  Device   ID Code        IR Length    Part Name
   1       0a001093           8        System_ACE_CF
   2       64250093          10        XC6VLX240T
  
  MicroBlaze Processor Configuration :
  -------------------------------------
  Version............................8.00.a
  Optimization.......................Performance
  Interconnect.......................PLB_v46
  MMU Type...........................No_MMU
  No of PC Breakpoints...............1
  No of Read Addr/Data Watchpoints...0
  No of Write Addr/Data Watchpoints..0
  Instruction Cache Support..........off
  Data Cache Support.................off
  Exceptions  Support................off
  FPU  Support.......................off
  Hard Divider Support...............off
  Hard Multiplier Support............on - (Mul32)
  Barrel Shifter Support.............on
  MSR clr/set Instruction Support....on
  Compare Instruction Support........on
  Data Cache Write-back Support......off
  
  Connected to "mb" target. id = 0
  Starting GDB server for "mb" target (id = 0) at TCP port no 1234
  The xmd engine has now opened a gdb server on port 1234.
  
Start the MicroBlaze GNU Debugger:

  rihuber@pc-10105:~/sdk_demo2/hello_world_0/Debug$ mb-gdb hello_world_0.elf
  GNU gdb 6.5
  Copyright (C) 2006 Free Software Foundation, Inc.
  GDB is free software, covered by the GNU General Public License, and you are
  welcome to change it and/or distribute copies of it under certain conditions.
  Type "show copying" to see the conditions.
  There is absolutely no warranty for GDB.  Type "show warranty" for details.
  This GDB was configured as "--host=i686-pc-linux-gnu --target=microblaze-xilinx-elf"...
  Connect to the gdb server provided by the xmd engine:
  
  (gdb) target remote localhost:1234
  Remote debugging using localhost:1234
  0x9000002c in __do_global_dtors_aux ()
  Download the executable to the hardware:
  
  (gdb) load
  Loading section .vectors.reset, size 0x8 lma 0x0
  Loading section .vectors.sw_exception, size 0x8 lma 0x8
  Loading section .vectors.interrupt, size 0x8 lma 0x10
  Loading section .vectors.hw_exception, size 0x8 lma 0x20
  Loading section .text, size 0x804 lma 0x90000000
  Loading section .init, size 0x24 lma 0x90000804
  Loading section .fini, size 0x1c lma 0x90000828
  Loading section .rodata, size 0x16 lma 0x90000844
  Loading section .data, size 0x110 lma 0x90000860
  Loading section .ctors, size 0x8 lma 0x90000970
  Loading section .dtors, size 0x8 lma 0x90000978
  Loading section .eh_frame, size 0x4 lma 0x90000980
  Loading section .jcr, size 0x4 lma 0x90000984
  Start address 0x0, load size 2466
  Transfer rate: 32880 bits/sec, 189 bytes/write.
  Set a breakpoint in main:
  
  (gdb) b main
  Breakpoint 1 at 0x900001b0: file ../src/helloworld.c, line 28.
  Start program execution:
  
  (gdb) c
  Continuing.
  
  Breakpoint 1, main () at ../src/helloworld.c:28
  28      init_platform();

 That's it!

* Getting started with networking *
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This part presents a short tutorial for building the Linux kernel, LANA
modules and the LANA example application, for loading LANA into the kernel
and for developing own functional blocks. This tutorial assumes that you
are using Debian GNU/Linux 6.0. The basic set of tools that are needed
can be obtained via apt-get with the following packages:

* build-essential
  (a Debian meta-package containing basic utilities and libraries for
   building software like gcc, make, g++, coreutils, bsdutils, util-linux,
   sed, tar and others)

* gdb
  (the GNU debugger)

* libncurses5 and libncurses5-dev
  (the graphical ncurses library, needed for ifpps)

* git
  (the distributed version control system)

* grub or grub2
  (a system boot loader, grub2 is default on most installations)

* vim, uemacs or similar
  (a command-line text editor)

* minicom
  (terminal emulation and text-based modem, for remote debugging via RS232)

* coccinelle
  (a semantic patching tool for C)

* flex
  (a fast lexical analyzer generator, needed for bpfc)

* bison
  (a parser generator that is compatible with YACC, needed for bpfc)

* libcelt0-0 and libcelt-dev
  (CELT codec, needed fot the LANA application)

* libspeexdsp1 and libspeexdsp-dev
  (Speex DSP, needed fot the LANA application)

* libasound2 and libasound2-dev
  (ALSA lib, needed fot the LANA application)

Optionally, it might be useful to port the Kernel Source Level Debugger (kgdb)
and the Kernel Source Level Debugger over Ethernet (kgdboe) without too much
efforts from (http://kgdb.linsyssoft.com/intro.htm) for kernel debugging to the
latest Linux release, since Linux explicitly avoids shipping a debugger within
the kernel.

++ Building Linux and LANA
--------------------------

For getting to know git, [http://linux.yyz.us/git-howto.html] gives a great
introduction.

In case you want a host-only LANA deployment (non-ML605), then do the
following:

 1) git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
 2) cd linux
 3) git checkout v2.6.37
 4) make menuconfig
    -- configure the kernel to your needs
    -- simplest case simply exit+save
 5) make -j `grep "^processor" /proc/cpuinfo | wc -l`
 6) make install
 7) make modules_install
 8) cd /boot/
 9) mkinitramfs -o initrd.img-2.6.37 2.6.37
10) update-grub
11) Boot into your new kernel

After the reboot, the LANA repository can then be fetched via Git with the
command (if not yet done):

  git clone git://github.com/EPiCS/reconos.git

and compiled through the following steps:

 1) cd reconos/linux/net/
 2) make

For user space tools, change into the following directories (have a look
into the tool description within the doc folder) and call 'make':

For manual stack configuration:
  - linux/tools/fbctl
  - linux/tools/vlink

For automatic stack configuration:
  - linux/tools/sensord
  - linux/tools/configd

Misc tools:
  - linux/tools/timedb
  - linux/tools/fbviz

In case you're cross-compiling these tools, comment in from the Makefiles:

 CC	=	microblaze-unknown-linux-gnu-gcc
 AR	=	microblaze-unknown-linux-gnu-ar

The same for cross compilation of the kernel modules, comment in the
following:

 ARCH		=	microblaze
 CROSS_COMPILE	=	microblaze-unknown-linux-gnu-
 KDIR		?=	~/linux-2.6-xlnx
 EXTRA_CFLAGS	+=	-I$(PWD)/../reconos/libreconos-ks/
 EXTRA_CFLAGS	+=	-DWITH_RECONOS

 export ARCH CROSS_COMPILE

and comment out:

 MDIR     := /lib/modules/$(shell uname -r)
 KDIR     := $(MDIR)/build

Then re-execute make. Make sure you have installed all the gnu utils as
described in Richard's howto.

In case you want to run LANA on the ML605, you need to copy all relevant
modules (*.ko) files and binaries to the compact flash card. Running it
via nfs is no option, since you will likely loose connection from the
moment you switch the kernel to your own stack.

Make sure you have configured kernel module support for the ML605 Linux
kernel, so that you can load these modules. In some old Paderborn kernel,
this was not the case.

In case you compile with -DWITH_RECONOS, then you also need the kernel
space version of libreconos-ks:

  1) cd linux/reconos/libreconos-ks
  2) make
  3) copy it to the cf card as well

++ Loading LANA kernel modules
------------------------------

In order to load the build kernel modules, do the following:

  1) insmod libreconos.ko  // if it was compiled for reconos
  2) insmod lana.ko        // the core module
  3) insmod fb_<name>.ko   // depending on what fb you want to use

     e.g.:
       insmod fb_eth.ko
       insmod fb_dummy.ko
       insmod fb_pflana.ko

Now none of the loaded functional blocks are active, yet. They have only been
registered to a functional block builder with a constructor and destructor as
well as a type identifier. To add instances of these functional blocks into the
LANA stack, do the following:

  1) vlink ethernet hook eth0          //vlink, since it's a vlink block
    --- vlink ethernet unhook eth0
  2) fbctl add fb0 ch.ethz.csg.dummy   //add dummy fb
    --- fbctl rm fb0

In case of a PF_LANA module, an instance will appear when a PF_LANA socket has
been opened by an application.

Now cat /proc/net/lana/fblocks shows functional block instances that are
currently present in LANA with many information about them:

# cat /proc/net/lana/fblocks 
name|type|address|idp|refcnt|bindings|transition|mapping|pkts|bytes|dropped|duration (jiffies)|properties
fb0 ch.ethz.csg.dummy ffff88021fccd000 1 1 [] norm sw 0 0 0 0 [reliable privacy]
fb1 ch.ethz.csg.dummy ffff8802300a6000 2 1 [] norm sw 0 0 0 0 [reliable privacy]
fb2 ch.ethz.csg.irr ffff88021fccd100 3 1 [] norm sw 0 0 0 0 [reliable]

In case a block gets bound via the bind/bind-e/bind-i command, dependencies
(in form of idps) become visible in this procfs file as well (fb1 was bound
with fb2 and eth0):

# cat /proc/net/lana/fblocks 
name|type|address|idp|refcnt|bindings|transition|mapping|pkts|bytes|dropped|duration (jiffies)|properties
fb0 ch.ethz.csg.dummy ffff88021fccd000 1 1 [] norm sw 0 0 0 0 [reliable privacy]
fb1 ch.ethz.csg.dummy ffff8802300a6000 2 7 [4 3] norm sw 0 0 0 0 [reliable privacy]
fb2 ch.ethz.csg.irr ffff88021fccd100 3 4 [2] norm sw 0 0 0 0 [reliable]
eth0 vlink ffff88021fccd200 4 4 [2] norm sw 0 0 0 0 []

Field descriptions:
	- name: fb instance name
	- type: fb instance type
	- address: pointer to instance structure
	- idp: idp number
	- refcnt: reference/usage counter
	- bindings: list of dependencies to other fbs
	- transition: flag if fblock is in transition phase
	- mapping: shows if fblock runs in sw or hw
	- pkts: # of packets that passed this fblock instance
	- bytes: # of bytes that passed this fblock instance
	- dropped: # of dropped packets from this instance
	- duration: execution time of this fblock in jiffies
	- properties: list of human readable string properties

Once a eth0 (et al.) functional block was initialized via vlink, it is still
possible to communicate with the old stack. Thus, dual-stack functionality is
enabled. In order to gather statistics about LANA-stack only packets, display
them via the PPE's (packet processing engine) procfs file:

# cat /proc/net/lana/ppe 
cpu|pkts|bytes|fblocks|timer-call|timer-cpu-miss|backlog-queue
CPU0:	0	0	0	10700	0	0
CPU1:	0	0	0	0	0	0

Field descriptions:
	- cpu: ksoftirqd execution cpu
	- pkts: # of packets that passed this CPU's PPE
	- bytes: # of bytes that passed this CPU's PPE
	- fblocks: # of fblocks that passed this CPU's PPE
	- timer-call: # of timer calls to invoke this CPU's PPE
	- timer-cpu-miss: # of times a timer call was scheduled on a wrong CPU (non-caller CPU)
	- backlog-queue: size of backlogged packets
