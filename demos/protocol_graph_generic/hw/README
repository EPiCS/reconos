This is a HowTo, which desribes the steps you have to do to create the partial reconfigurable 
hardware design for the protocol graph demo.

The system design looks like this:

  -------------------------------------------------------
 |                                                       |
 |    ------------------           ------------------    |
  --> | NoC Switch | 1 |  -------> | NoC Switch | 0 | ---
      ------------------           ------------------
           /        \                 /         \
       -------   -------           -------   ========
       | ETH |   | H2S |           | S2H |   || PR || <---- partial reconfigurable (PR) slot
       -------   -------           -------   ======== 

We have four functional blocks (FB) in hardware, which are connected with each other 
over a network-on-chip.

(1) the 'ETH' FB is connected to the physical network interface (Phy) of the FPGA. 
    It receives packets from the Phy and transmits packets to the Phy
(2) the 'H2S' FB forwards packets from the hardware network-on-chip to the software
    The software runs on a Xilinx MicroBlaze soft-core CPU that runs Linux 2.6 and 
    some kernel modules (such as libreconos.ko and pr_hw_sw_interface.ko)
(3) the 'S2H' FB receives packets from the software and inserts them to the network-on-chip
(4) the 'PR' slot is the only partial reconfigurable slot/module in our design. 
    In this demo we can either configure the 'PR_aes' or the 'PR_ips' FB to this slot. 
    The PR_aes block decrypts all packets with the aes algorithm and the PR_ips block
    checks all packets for non-shortest forms UTF8 encoding.

-----------------------------------------------------------------------------------------------

For our demo we require the following four bitstreams:

[1] system_aes.bit:  full bitstream, where 'PR_aes' is configured into the 'PR' slot (configuration A)
[2] system_ips.bit:  full bitstream, where 'PR_ips' is configured into the 'PR' slot (configuration B)
[3] partial_aes.bit: partial bitstream for the 'PR_aes' FB
[4] partial_ips.bit: partial bitstream for the 'PR_ips' FB

-----------------------------------------------------------------------------------------------

To generate these bitstreams you have to follow these steps:

STEP 1: Generate static and partial netlists for configuration A
================================================================
- Install the Xilinx 14.5 tools to your system (if this is not already the case)
- Check that all symbolic links in hw/edk/pcores are set correctly
- Copy the pcore hw/edk/pcores/hwt_aesde_v1_00_b/hwt_pr_v1_00_a to hw/edk/pcores/
- Open 'hw/edk/system.xmp' using the Xilinx Platform Studio (XPS) and click on 'Hardware>Generate Netlist'

STEP 2: Copy static and partial netlists to the 'hw/prdesign'
=============================================================
- Copy all netlists (*.ngc) from the folder 'hw/edk/implementation' to 'hw/prdesign/syn/static'
- Move the partial netlist 'system_hwt_pr_0_wrapper.ngc' from 'hw/prdesign/syn/static' to 'hw/prdesign/syn/pr_a'

STEP 3: Generate partial netlists for configuration B
=====================================================
- delete the folder hw/edk/pcores/hwt_pr_v1_00_a
- copy the folder hw/edk/pcores/hwt_ips_v1_00_a to hw/edk/pcores/
- Open 'hw/edk/system.xmp' using the Xilinx Platform Studio (XPS) and click on 'Hardware>Clean Hardware' [not necessary]
- Generate the netlists: Hardware > Generate Netlists. You can stop as soon as the system_hwt_pr_0_wrapper.ngc file is available.  [not necessary]
- go to the directory hw/edk/synthesis and add the following line to thefile system_hwt_pr_0_wrapper_xst.scr
	-bufg 0
- on the command line type the followig:
xst -ifn system_hwt_pr_0_wrapper_xst.scr > xst_out.txt
grep through xst_out.txt for BUFG to verify no BUFGs are instantiated.


STEP 4: Copy partial netlist/s to the 'hw/prdesign'
===================================================
- Copy the partial netlist 'system_hwt_pr_0_wrapper.ngc' from the folder 'hw/edk/implementation' to 'hw/prdesign/syn/pr_b'.

STEP 5: Generate bitstreams for configuration A
================================================
- goto the folder 'hw/prdesign/imp/config_pr_a' and call './generate_config.sh'
- this step will create the full bistream 'system.bit' and the partial bitstream for configuration A 
- copy the full bitstream 'hw/prdesign/imp/config_pr_a/system.bit' to 'hw/prdesign/bitfiles/system_aes.bit'
- copy the partial bitstream 'hw/prdesign/imp/config_pr_a/system_hwt_pr_0_hwt_pr_a_partial.bin' 
  to 'hw/prdesign/bitfiles/partial_aes.bit' (important: the file *.bin contains the partial bitstream without a header)

STEP 6: Generate bitstreams for configuration B
================================================
- goto the folder 'hw/prdesign/imp/config_pr_b' and call './generate_config.sh'
- this step will create the full bistream 'system.bit' and the partial bitstream for configuration B 
- copy the full bitstream 'hw/prdesign/imp/config_pr_b/system.bit' to 'hw/prdesign/bitfiles/system_ips.bit'
- copy the partial bitstream 'hw/prdesign/imp/config_pr_b/system_hwt_pr_0_hwt_pr_b_partial.bin' 
  to 'hw/prdesign/bitfiles/partial_ips.bit' (important: the file *.bin contains the partial bitstream without a header)

STEP 7: Build the kernel
========================
- copy the device tree from hw/device_tree/noc_with_cache_mmu.dts to /path/to/kernel/arch/microblaze/boot/dts/
- compile the kernel: 
make CROSS_COMPILE=microblaze-unknown-linux-gnu- ARCH=microblaze clean -j4 simpleImage.noc_with_cache_mmu

STEP 8: Build the software
==========================
- go to the /sw folder (cd ../sw) and generate the kernel-module and the send_pkts application (using make)
- copy the kernel module 'pr_hw_sw_interface.ko' to the compact flash card, 
  which should already contain the current libreconos.ko, fsl.ko, etc. 

STEP 9: Configure the FPGA and download the kernel image
========================================================
- download the system_ips.bit using Xilinx Impact or the 'dow' script (not the system_aes.bit!)
- download the Linux kernel image ('simpleImage.noc_with_cache_mmu') using the 'xmd' tool or the 'dow' script

STEP 10: Test the system
========================
- open minicom in a terminal (e.g. 'minicom -D /dev/ttyUSB0')
- if does not already exist: mknod /dev/icap0 c 259 0
- configure the protocol graph demo according to the file 'sw/config.sh' (line 2-4)
- the kernel module first wait for a message from the network interface
  -> call the 'sw/send_pkts/send_pkts' application on your workstation 
     to send a single packet over the eth1 interface to the FPGA
- then you have 30 seconds to reconfigure the partial slot ('[partial slot] reconfig. START')
  -> first hit the 'enter'-key such that you go back to the terminal
  -> in the terminal you can now download the aes partial bitstream
     =>> for pr_aes: 'cat partial_bitstreams/partial_aes.bit > /dev/icap0' or 'AES'
     =>> for pr_ips: 'cat partial_bitstreams/partial_ips.bit > /dev/icap0' or 'IPS'
- after 30 seconds, you should not reconfigure anymore, this is indicated by the output '[partial slot] reconfig. STOP'
  -> the kernel module will again wait for another message (that could be send using sw/send_pkts/send_pkts)
- and so on and so on...
  -> the kernel module expects that the hardware is changed from ips to aes etc. each time it waits, and 
	configures the partial slot accordingly. Since aes and ips do not have the same configuration interface
	the system wont work if the kernel module assumes the wrong partial module is configured.


